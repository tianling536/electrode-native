import { YarnLockParser } from '../src/YarnLockParser';
import { expect } from 'chai';
import { createTmpDir, PackagePath } from 'ern-core';
import fs from 'fs';
import path from 'path';

const yarnLockFixture = `
# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
# yarn lockfile v1

DepA@^1.0.1:
  version "1.0.1"
  resolved "https://registry.yarnpkg.com/DepA/-/DepA-1.0.1.tgz#d4d255f326fbbb01a0f73a5c4d073a68e36b4b18"
  dependencies:
    DepB "^1.0.0"

DepA@^2.0.0:
  version "2.0.3"
  resolved "https://registry.yarnpkg.com/DepA/-/DepA-2.0.3.tgz#9ead385585913d4d7493ea111a98c94fde9ce701"
  dependencies:
    DepB "^1.0.4"

DepB@^1.0.0, DepB@^1.0.4:
  version "1.0.5"
  resolved "https://registry.yarnpkg.com/DepB/-/DepB-1.0.5.tgz#9cd91f9c97c866caeb0233e3d631c974d629066e"

DepC@^1.0.0:
  version "1.0.0"
  resolved "https://registry.yarnpkg.com/DepC/-/DepC-1.0.0.tgz#bae7948e9a56868898998f3baa0cce369bb42c7c"
  dependencies:
    DepB "^1.0.0"

DepD@^1.0.0:
  version "1.0.0"
  resolved "https://registry.yarnpkg.com/DepD/-/DepD-1.0.4.tgz#9347b72c37b4e33a17ccec2d5e82935836d2cd0f"
`;

describe('YarnLockParser', () => {
  describe('fromPath', () => {
    it('should throw if the path to yarn.lock does not exist', () => {
      expect(() =>
        YarnLockParser.fromPath('/non/existing/path/to/yarn.lock'),
      ).to.throw();
    });

    it('should not throw if the path to yarn.lock exist', () => {
      const tmpDir = createTmpDir();
      const pathToYarnLock = path.join(tmpDir, 'yarn.lock');
      fs.writeFileSync(pathToYarnLock, yarnLockFixture);
      expect(() => YarnLockParser.fromPath(pathToYarnLock)).to.not.throw();
    });
  });

  describe('findPackage', () => {
    it('should return all versions of package if no specific version is requested', () => {
      const sut = YarnLockParser.fromContent(yarnLockFixture);
      const res = sut.findPackage(PackagePath.fromString('DepA'));
      expect(res).deep.equal([
        {
          pkgPath: PackagePath.fromString('DepA@^1.0.1'),
          version: '1.0.1',
        },
        {
          pkgPath: PackagePath.fromString('DepA@^2.0.0'),
          version: '2.0.3',
        },
      ]);
    });

    it('should only return matched version if a specific version is requested', () => {
      const sut = YarnLockParser.fromContent(yarnLockFixture);
      const res = sut.findPackage(PackagePath.fromString('DepA@^2.0.0'));
      expect(res).deep.equal([
        {
          pkgPath: PackagePath.fromString('DepA@^2.0.0'),
          version: '2.0.3',
        },
      ]);
    });

    it('should return an empty array if dependency is not found', () => {
      const sut = YarnLockParser.fromContent(yarnLockFixture);
      const res = sut.findPackage(PackagePath.fromString('DepZ'));
      expect(res).empty;
    });

    it('should return an empty array if no matching version of dependency is found', () => {
      const sut = YarnLockParser.fromContent(yarnLockFixture);
      const res = sut.findPackage(PackagePath.fromString('DepA@5.0.0'));
      expect(res).empty;
    });
  });

  describe('findPackagesWithDependency', () => {
    it('should return all packages that have a dependency on a given package version', () => {
      const sut = YarnLockParser.fromContent(yarnLockFixture);
      const res = sut.findPackagesWithDependency(
        PackagePath.fromString('DepB@^1.0.0'),
      );
      expect(res).deep.equal([
        {
          pkgPath: PackagePath.fromString('DepA@^1.0.1'),
          version: '1.0.1',
        },
        {
          pkgPath: PackagePath.fromString('DepC@^1.0.0'),
          version: '1.0.0',
        },
      ]);
    });
    ['DepB@^1.1.0', 'DepD@^1.0.0', 'DepZ@1.0.0'].map((d) => {
      it(`should return an empty array if no package has a dependency on a given package version [${d}]`, () => {
        const sut = YarnLockParser.fromContent(yarnLockFixture);
        const res = sut.findPackagesWithDependency(PackagePath.fromString(d));
        expect(res).empty;
      });
    });
  });

  describe('buildDependencyTree', () => {
    [
      {
        dep: PackagePath.fromString('DepB'),
        expected: {
          'DepB@^1.0.0 [1.0.5]': {
            'DepA@^1.0.1 [1.0.1]': {},
            'DepC@^1.0.0 [1.0.0]': {},
          },
          'DepB@^1.0.4 [1.0.5]': {
            'DepA@^2.0.0 [2.0.3]': {},
          },
        },
      },
      {
        dep: PackagePath.fromString('DepA'),
        expected: {
          'DepA@^1.0.1 [1.0.1]': {},
          'DepA@^2.0.0 [2.0.3]': {},
        },
      },
      {
        dep: PackagePath.fromString('DepZ'),
        expected: {},
      },
    ].map((x) => {
      it(`should build the correct dependency tree for ${x}`, () => {
        const sut = YarnLockParser.fromContent(yarnLockFixture);
        const res = sut.buildDependencyTree(x.dep);
        expect(res).deep.equal(x.expected);
      });
    });
  });
});
